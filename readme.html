<html>
	<head>
		<title>NS73M Arduino Driver</title>
		<style>
			h1 {
				font-family: "Helvetica","Verdana",sans;
				font-size: x-large;
				font-style: bold;
			}

			h2 {
				font-family: "Helvetica","Verdana",sans;
				font-size: large;
				font-style: bold;
				margin-top: 25px;
			}
			
			p {
				font-family: "Georgia",serif;
				margin-top: 12px;
				margin-bottom: 12px;
			}
			
			body {
				background-color: #EEEEEE;
			}
			
			li {
				font-family: "Georgia",serif;
				margin-bottom: 5px;
			}
			
			#content {
				border-width: 3px;
				border-style: solid;
				border-color: #555555;
				margin-left: auto;
				margin-right: auto;
				padding-top: 0px;
				padding-left: 20px;
				padding-right: 20px;
				background-color: white;
				font-family: "Helvetica", "Verdana", sans;
				width:	600px;
			}
		</style>
	</head>
<body>
<div id="content">
	<p><h1>NS73 Arduino Driver</h1></p>
	<p>Arduino driver for the Niigata Seimitsu NS73M low-power FM transmitter. <br>Copyright (C) 2012 Conor Peterson (conor.p.peterson@gmail.com)</p>
	
	<p><h2>License</h2></p>
	
	<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
	
	<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
	You should have received a copy of the GNU General Public License along with this program.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
	
	<p><h2>About this driver</h2></p>
	<p>This is an Arduino driver for the Niigata Seimitsu NS73M low-power FM transmitter. Besides basic frequency selection it also implements most other interesting features of the chip including adjustable input sensitivity and transmission power, muting, and the ability to take the transmitter offline.
	At present it uses SPI to communicate with the NS73M, though I2C support may be possible in the future. It requires approximately 32 bytes of RAM and 30 bytes of EEPROM to store calibration information.</p>
	
	<p><h2>Basic use</h2></p>
	<p><ol>
	<li>Copy NS73.cpp and NS73.h into your sketch folder. Make sure to #include "NS73.h" at the top of your sketch.</li>
	<li>Call begin() with the pins the NS73 is attached to.</li>
	<li>Call setChannel() or setFrequency()* (*see advanced notes)</li>
	<li>Call goOnline() to bring the transmitter online.</li>
	<li>Adjust channel as you see fit. You do not need to take the transmitter offline to change channels.</li>
	<li>Change transmission power, muting, input level etc. whenever you like.
	</ol></p>
	
	<p><h2>Advanced usage notes</h2></p>
	<p><ul>
	<li>You can use setFrequency() to directly set the frequency without having to look up the channel number. The argument is an int. setFrequency(875) = 87.5 MHz. setFrequency(1015) = 101.5 MHz etc. If you attempt to set it between channels, it will round down to the nearest channel.</li>
	<li>getFrequency() is similar. It returns an int. You can use this to help drive an LCD display. You have to figure out the decimal place on your own. ;)</li>
	<li>The NS73 does need some calibration in order to lock onto certain frequencies. The built-in calibration is pretty good and has been found to work for many chips. If it fails to get a frequency lock when changing channels, the driver will attempt to adjust the oscillator. This might take two full seconds! If it succeeds, it will modify the calibration table and future channel changes will happen much faster.</li>
	</ul></p>
	
	<p><h2>Connecting to your Arduino</h2></p>
	<p>To use an NS73 breakout board from Sparkfun in your Arduino project, connect its power to the arduino's 3.3v power rail, connect the gnds, and tie the IIC pin to gnd. The arduino communicates at +5V, which will potentially cook your NS73. DO NOT CONNECT THE I/O LINES TOGETHER!</p>
	<p>To avoid this you MUST use special circuitry on the data, latch and clock lines. (TEB is OK as is). I prefer to do this with a 3.3v Zener diode (1N5226B) and a 10k&ohm; resistor. Try a google search for "level shift zener diode." Basically: connect the outgoing I/O line from the Arduino to the black band leg of the zener diode. Connect the other leg of the diode to the 10K&ohm; resistor. Connect the other leg of the resistor to ground. Connect the appropriate I/O line on the NS73M module to the junction between the zener diode and the resistor.</p>
	<p>There are other more and less robust ways to accomplish this level shift. Note the unidirectional i/o. The NS73 never needs to talk back to the Ardunio which simplifies matters.</p>
	
	<p><h2>About CEX</h2></p>
	<p>The NS73 obtains its VHF carrier signal by implementing a small frequency synthesizer. The input is a 32.768 KHz crystal (supplied on the breakout board) which is then divided down to 8.192KHz. It then uses a clock multiplied phase-locked loop to produce signals in the VHF band. The PLL has a couple of registers available for adjustment. The first are the charge pumps. My guess is that these control the power available to the PLL to correct itself when the output frequency needs to change. Typically you bring the main synthesizer charge pump to 80&micro;A when changing frequency and drop it back to the lower setting after it stabilizes. The status of the PLL is expressed through the TEB line: if TEB is high, the synthesizer has a good lock.</p>
	<p>The second adjustment is CEX, or Oscillator Extension. I do not know fully understand the underlying mechanism is, but it acts as a coarse adjustment for the synthesizer. It has four settings. Higher frequencies use lower bands and vice versa. If the CEX setting is wrong for any given frequency, the synthesizer will fail to get a lock. The driver detects this condition and attempts to correct for it. If it successfully recovers the new setting is committed to EEPROM.</p>
	<p>If you wish to force a total recalibration of your NS73, modify the default CEX bands to junk settings (all bands start at channel 0, for example), clear the Arduino's EEPROM, and force the chip to try all channels in sequence. Sometimes it takes multiple passes to get a good calibration for every channel. You'll know that calibration is complete when you can hit every channel without ever losing a TEB lock.</p>
	
	<p><h2>Acknowledgements</h2></p>
	<p>Hat tip to Lee Montgomery of <a href="http://neighborhoodpublicradio.org">Neighborhood Public Radio</a>.</p>
	</div>
</body>
</html>